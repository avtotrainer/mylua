# Lua

ua-ს ცხრილი (table) არის მთავარი მონაცემთა სტრუქტურა და ყველაზე მეტად
მრავალმხრივი მონაცემთა ტიპი. ცხრილი წარმოადგენს ასოციაციურ მასივს, სადაც
თითოეული ელემენტი არის გასაღების და მნიშვნელობის წყვილი. ცხრილი შეიძლება
შეიცავდეს ცვლადებს, ფუნქციებს, სხვა ცხრილებს და ა.შ.

აქ არის ძირითადი მაგალითი, თუ როგორ მუშაობს ცხრილი Lua-ში:

## ცხრილის შექმნა

```lua
local myTable = {}  -- ცარიელი ცხრილი
```

### გასაღებების და მნიშვნელობების დამატება

```lua
myTable["key1"] = "value1"
myTable.key2 = "value2"  -- წვდომა გრძელი წერტილით
```

### რიცხვითი გასაღებების გამოყენება

```lua
myTable[1] = "first value"
myTable[2] = "second value"
```

### წვდომა ცხრილის ელემენტებზე

```lua
print(myTable["key1"])  -- ბეჭდავს: value1
print(myTable.key2)     -- ბეჭდავს: value2
print(myTable[1])       -- ბეჭდავს: first value
print(myTable[2])       -- ბეჭდავს: second value
```

### ცხრილის სხვადასხვა გამოყენება

Lua-ს ცხრილები შეიძლება გამოყენებულ იქნას როგორც მასივები, ასოციაციური მასივები
(ანმახასიათებლები), ჩანაწერები (record), სტეკები, რიგები (queue), და ა.შ.

## ცხრილის და ფუნქციების გამოყენება ერთად

```lua
local person = {
    name = "John",
    age = 30,
    greet = function(self)
        print("Hello, my name is " .. self.name)
    end
}

person:greet()  -- ბეჭდავს: Hello, my name is John
```

### ჩადგმული ცხრილები

```lua
local complexTable = {
    numbers = {1, 2, 3},
    info = {
        name = "example",
        value = 42
    }
}

print(complexTable.numbers[1])    -- ბეჭდავს: 1
print(complexTable.info.name)     -- ბეჭდავს: example
```

### ცხრილის იტერაცია

```lua
for key, value in pairs(myTable) do
    print(key, value)
end
```

### ძირითადი ცხრილების ფუნქციები

Lua-ს სტანდარტული ბიბლიოთეკა შეიცავს რამდენიმე სასარგებლო ფუნქციას
ცხრილებისათვის, მაგალითად:

```lua
local myList = {5, 3, 8, 1}

table.insert(myList, 2)  -- myList: {5, 3, 8, 1, 2}
table.sort(myList)       -- myList: {1, 2, 3, 5, 8}
table.remove(myList, 3)  -- myList: {1, 2, 5, 8}
```

### ცხრილის სიგრძე

```lua
print(#myList)  -- ბეჭდავს: 4, რადგან myList ახლა აქვს 4 ელემენტი
```

Lua-ს ცხრილი არის ძალიან ძლიერი და მორგებადი მონაცემთა სტრუქტურა, რომელიც
შეიძლება გამოყენებულ იქნას სხვადასხვა სახით. თუ რაიმე კონკრეტული კითხვა გაქვთ
ცხრილების გამოყენების ან კონკრეტული მაგალითების შესახებ, გთხოვთ, მითხარით.

```lua
local M = {}
```

ეს ხაზი ქმნის ცარიელ ცხრილს, რომელსაც მიენიჭა სახელი `M`. ეს ცხრილი
მოგვიანებით გამოვიყენებთ როგორც მოდულის დაბრუნების მნიშვნელობას.

```lua
local function lsp()
```

ეს ხაზი აცხადებს ფუნქციას `lsp`, რომელიც არის ლოკალური ფუნქცია და ხელმისაწვდომი
იქნება მხოლოდ ამ მოდულში.

```lua
  if rawget(vim, "lsp") then
```

ამ ხაზით ვამოწმებთ, არსებობს თუ არა `vim.lsp` ობიექტი. `rawget` ფუნქცია
გამოიყენება, რათა აირიდოთ გადატვირთვის დაცვა.

```lua
    for _, client in ipairs(vim.lsp.get_clients()) do
```

ეს ხაზი ასრულებს ლუპს, რომელიც გადის ყველა აქტიურ LSP კლიენტს, რომელიც
მიღებულია `vim.lsp.get_clients()` ფუნქციით.

```lua
      local stbufnr = vim.api.nvim_win_get_buf(vim.g.statusline_winid)
```

ეს ხაზი იღებს მიმდინარე ფანჯრის ბუფერის ID-ს.

```lua
      -- ignore copilot
```

ეს კომენტარი აღნიშნავს, რომ შემდეგი კოდი გამოტოვებს "copilot" კლიენტს.

```lua
      if client.attached_buffers[stbufnr] and client.name ~= "copilot" then
```

ეს ხაზი ამოწმებს, არის თუ არა `client.attached_buffers` ბუფერი დაკავშირებული
მიმდინარე ფანჯარასთან და არაა "copilot".

```lua
        return (vim.o.columns > 100 and "%#St_LspStatus#" .. "   LSP ~ " ..
            client.name .. " ") or "   LSP "
```

თუ ზემოთ მოცემული პირობები შესრულდა, ეს ხაზი აბრუნებს სტრიქონს, რომელიც შეიცავს
LSP კლიენტის სახელს, თუ ფანჯრის სვეტების რაოდენობა 100-ზე მეტია, ან უბრალოდ LSP
სიმბოლოს.

```lua
      end
    end
  end
end
```

ეს ხაზები ხურავს პირობებს და ციკლს.

```lua
M.ui = {
  theme = "nightowl",
  tabufline = {
    order = { "treeOffset", "buffers", "tabs" },
  },
  statusline = {
    separator_style = "block",
    modules = {
      lsp = lsp,
    },
  },
}
```

ეს კოდი ქმნის `ui` კონფიგურაციის ცხრილს `M` მოდულში, რომელიც შეიცავს თემას,
ტაბების რიგს და სტატუსის ხაზის მოდულებს, რომელთაგან ერთ-ერთი არის ზემოთ
განსაზღვრული `lsp` ფუნქცია.

```lua
-- Import markdown configuration
require "configs.markdown"
```

ეს ხაზი ითხოვს `configs.markdown` მოდულს და მოაქვს მისი კონფიგურაცია ამ ფაილში.

```lua
return M
```

ეს ხაზი აბრუნებს `M` ცხრილს, როგორც ამ Lua მოდულის დაბრუნების მნიშვნელობას.

---

ვიმედოვნებ, რომ ეს ახსნა დაგეხმარება Lua-ს შესწავლაში. თუ რაიმე კონკრეტული
ნაწილი არ არის გასაგები, შეგვიძლია უფრო დეტალურად განვიხილოთ.
